\chapter{Обработка данных с использованием python}

Для удобства, предлагаю в этой главе повторить некоторые этапы мой научной работы, в процессе осваивая те или иные инструменты. Таким образом, предлагаю поставить цель "Изучение фазовой диаграммы плотного нагретого водорода в рамках метода волновых пакетов eFF".

\section{Коротко о методе волновых пакетов eFF}

Между ньютоновской молекулярной динамикой (вы рассматриваете частицы как набор взаимодействующий "бильярдных шаров", без введения электронов) и квантовой молекулярной динамикой (где вы решаете уравнение Шредингера, и от него рассчитываете дальнейшее движение ионов) существует еще один вид молекулярной динамики, это метод волновых пакетов. В метоле волновых пакетов, у вас электроны представлены в виде набора функция, например одной функции Гаусса в eFF. В результате для такой функции уравнение Шредингера приведет к введение дополнительного потенциала для электронов и вы сможете моделировать все в рамках классической молекулярной динамики.  


\begin{enumerate}
 \item Статья с введением eFF: \url{https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.185003}
 \item Введение eFF в Lammps: \url{https://onlinelibrary.wiley.com/doi/full/10.1002/jcc.21637}
 \item Потенциал в Lammps: \url{https://lammps.sandia.gov/doc/pair_eff.html}  
\end{enumerate}

 
\section{Сборка LAMMPS}

Пакет electron Force Field в Lammps является дополнительным и при сборке не поставляется. Нам необходимо подключить его до выполнения сборки:

\begin{minted}[frame=lines]{bash}
#! Внимание, собирать lammps не обязательно, вы можете использовать уже собранный мной бинарник.
cd lammps*/src
make yes-user-eff
# не забудьте перед этим подключить модуль intel
module load mpi/openmpi4-x86_64
module load gcc/8.3.0
make -j8 mpi
# в папке появится файл lmp_mpi, скопируйте его себе в bin/
cp  lmp_mpi ~/bin/
\end{minted}

Уже собранный бинарник вы можете скачать в свою папку bin (создайте если у вас ее нет (mkdir ~/bin):

\begin{minted}[frame=lines]{bash}
cp /tmp/tscm_course/bins/lmp_mpi ~/bin/
\end{minted}

\textbf{Проверка расчета в eFF}

\begin{minted}[frame=lines]{bash}
# Перейдем в стандартный пример Lammps
cd lammps/examples/USER/eff/H2
srun -N 1 --ntasks-per-node=4 -p RT -J lammps_melt --comment="lammps test melting" ~/bin/lmp_mpi -in in.h2
\end{minted}

\section{Тестовый расчет eFF в LAMMPS}

\begin{minted}[frame=lines]{bash}
# Скопируем себе в папку пример расчета \textbf{H_plasma}
cp ~/repos/lammps-29Oct20/examples/USER/eff/H_plasma ~/study/Lesson5
cd ~/study/Lesson5/H_plasma

# Создадим файл для запуска Slurm (sbatch.sh) следующего содержания:
# ------------------------------------------
#!/bin/bash
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=8
#SBATCH --partition=RT
#SBATCH --job-name=lammps_fedoorv
#SBATCH --comment="Fedorov Lammps test"
srun ~/bin/lmp_mpi -in in.h2bulk.nve
# ------------------------------------------

# Запустим этот файл
sbatch sbatch.sh

# Задача добавится в очередь, проверим ее
squeue
# Если в таблице пусто, то значит задача посчиталась и в папке появился файл slurm-*
# В этом файле весь вывод расчета LAMMPS.
\end{minted} 

\section{Расчет водорода при температуре 2000K и плотности 0.3 г/см$^3$ в рамках eFF}

Моя работа, часть которой мы хотим повторить (про eFF). \url{https://journals.aps.org/prb/abstract/10.1103/PhysRevB.101.100101}

\subsection{Создание конфигурации для заданной плотности}

Нам необходимо собрать систему из молекул $H_2$ с плотностью 0.3 g/cc и как можно более "жидким" составом. Для достаточно быстрого расчета, но при этом достаточно информативного, нам хватит 500 молекул $H_2$.

Для такой плотности, нам необходимо, чтобы расчетная коробка была со стенкой размера 17.7\,А (\textbf{проверьте})

Для начала напишем функцию, которая бы получая на вход координаты центра молекулы, возвращала бы координаты всех 4 частиц (2-х ионов и 2-х электронов), при этом желательно чтобы молекула была повернута как можно хаотичнее. 

\begin{minted}[frame=lines]{python}
import numpy as np
def get_h2(r):
    alpha=np.random.rand()*np.pi
    betta=np.random.rand()*2*np.pi
    data=[]
    h=0.37
    z_h=h*np.sin(alpha)
    x_h=h*np.cos(alpha)*np.cos(betta)
    y_h=h*np.cos(alpha)*np.sin(betta)
    r_h=np.array([x_h,y_h,z_h])
    data.append([0, r+r_h])# первый элемент - спин (ион-0)
    data.append([0, r-r_h])# первый элемент - спин (ион-0)
    h=0.1
    z_h=h*np.sin(alpha)
    x_h=h*np.cos(alpha)*np.cos(betta)
    y_h=h*np.cos(alpha)*np.sin(betta)
    r_h=np.array([x_h,y_h,z_h])
    data.append([1, r+r_h]) #  первый элемент - спин
    h=-0.2
    z_h=h*np.sin(alpha)
    x_h=h*np.cos(alpha)*np.cos(betta)
    y_h=h*np.cos(alpha)*np.sin(betta)
    r_h=np.array([x_h,y_h,z_h])
    data.append([-1, r+r_h]) # первый элемент - спин

    return data
\end{minted}

\textbf{Задание на дом:}

Написать функцию structure\_generator(a=17.7,n=500), которая бы распределяла 500 молекул водорода из последнего скрипта внутри коробки с размером 17.7 так, чтобы молекулы друг на друга не накладывались и находились достаточно далеко друг от друга. 

Я бы рекомендовал разделить этот куб на ячейки, так чтобы они делили его 10x10x10 (при этом минимальное расстояние между двумя молекулами 1.7, что достаточно при размере молекулы в 0.74). То есть:

\begin{minted}[frame=lines]{python}
for x_i in range(0, a, 0.1*a)
    for y_i in range(0, a, 0.1*a)
          for z_i in range(0, a, 0.1*a)
\end{minted}

И заполнить рандомно (именно не последовательно) 500 из этих 1000 позиций. в выводе должен быть массив из 2 тыс координат частиц, в виде в котором это представлено на прошлом коде, там такой массив из 4 координат получился. Для тех кто не в курсе, первый элемент массива это спин, для иона он 0
